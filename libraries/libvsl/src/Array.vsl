import glibc

/**
 * An array is a linear sequence of values. In VSL an array is dynamically
 * expanded and shrinked. If you wish to use a C-like array you can use
 * @link(CArray) which is a wrapper over @link(Pointer<T>). This has a
 * statically has a fixed initial capcaciy but the optimizer may expand or
 * shrink it as applicable. Additionally this may be converted to a CArray if
 * it is not changed.
 */
public class Array<Type>: Sequence<Type> {
    private var capacity: Int
    private var _len: Int = 0
    private var start: Pointer<Type>
    
    public init(capacity: Int = 10) {
        self.capacity = capacity
        self.start = malloc<Type>(capcity)
    }

    deinit { free(self.start) }
    
    public subscript(value: Int) -> Type? {
        get {
            if value > self._len: return nil
            if value < 0: value + self._len
            return self.start.moved(up: value).value()
        }
        
        set(value: Type) {
            if value > self._len: return nil
            if value < 0: return nil
            
            self.start.moved(up: value).set(to: value)
        }
    }
    
    public var length: Int { return self._len }
    
    public class Iterator<Type>: VSL.Iterator<Type> {
        private let array: Array<Type>
        private let index: Int = 0
        
        public init(array: Array<Type>) {
            self.array = array
        }
        
        public func next() -> Type? {
            defer { self.index += 1 }
            return self.array[self.index]
        }
    }
    
    public var iterator: Iterator<Type> { return Array.Iterator<Type>(self) }
}
